import time
import requests
import json
import os
from datetime import datetime

# ANSI color codes for enhanced output
RED = "\033[91m"
YELLOW = "\033[93m"
GREEN = "\033[92m"
BLUE = "\033[94m"
RESET = "\033[0m"
BOLD = "\033[1m"

def countdown(label, seconds, color=""):
    """Display a countdown timer with a label and color."""
    for sec in range(seconds, 0, -1):
        print(f"{color}{label} in {sec}...{RESET}", end="\r")
        time.sleep(1)
    print(f"{color}{label}: GO!{' ' * 20}{RESET}")

# Base Class: System
class System:
    def __init__(self, config):
        self.config = config
        print(f"\n{BOLD}{BLUE}Smart Traffic Management System Initialized{RESET}")
        print(f"{BLUE}Simulation Duration: {config['simulation_duration']} sec | Weather: {config['weather_condition']} | Temp: {config['temperature']}Â°C{RESET}")

# Google Maps API Integration
class GoogleMapsIntegration:
    def __init__(self, api_key):
        self.api_key = api_key
        print(f"{BLUE}Google Maps API Integration Initialized{RESET}")

    def get_traffic_data(self, latitude, longitude, radius=500):
        base_url = "https://roads.googleapis.com/v1/nearestRoads"
        try:
            print(f"{BLUE}Fetching traffic data for coordinates: {latitude}, {longitude}{RESET}")
            # Simulated traffic data
            directions = ["North", "East", "South", "West"]
            congestion_levels = {}
            current_hour = datetime.now().hour
            is_rush_hour = (7 <= current_hour <= 9) or (17 <= current_hour <= 19)
            import random
            for direction in directions:
                if is_rush_hour:
                    congestion = random.choice(["high", "high", "high", "medium", "low"])
                else:
                    congestion = random.choice(["low", "low", "medium", "medium", "high"])
                congestion_levels[direction] = congestion
            print(f"{GREEN}Successfully retrieved traffic data for all directions{RESET}")
            return congestion_levels
        except Exception as e:
            print(f"{RED}Error fetching traffic data: {str(e)}{RESET}")
            return {direction: "medium" for direction in ["North", "East", "South", "West"]}

    def get_weather_data(self, latitude, longitude):
        try:
            print(f"{BLUE}Fetching weather data for coordinates: {latitude}, {longitude}{RESET}")
            import random
            weather_conditions = ["sunny", "cloudy", "rainy", "snowy", "foggy"]
            temperature = random.randint(-5, 35)
            condition = random.choice(weather_conditions)
            print(f"{GREEN}Weather: {condition}, Temperature: {temperature}Â°C{RESET}")
            return {
                "condition": condition,
                "temperature": temperature
            }
        except Exception as e:
            print(f"{RED}Error fetching weather data: {str(e)}{RESET}")
            return {
                "condition": "unknown",
                "temperature": 20
            }

# TrafficSignal Class
class TrafficSignal(System):
    def __init__(self, config):
        super().__init__(config)
        print(f"{BLUE}Traffic Signal Installed{RESET}")

    def signal_cycle(self, red_duration, yellow_duration, green_duration):
        print(f"\n{GREEN}GREEN LIGHT for {green_duration} sec{RESET}")
        countdown("Green Light", green_duration, GREEN)
        print(f"\n{YELLOW}YELLOW LIGHT for {yellow_duration} sec{RESET}")
        countdown("Yellow Light", yellow_duration, YELLOW)
        print(f"\n{RED}RED LIGHT for {red_duration} sec{RESET}")
        countdown("Red Light", red_duration, RED)

# EmergencyHandler Mixin
class EmergencyHandler:
    def emergency_override(self, directions, emergency_direction, emergency_cross_time):
        print(f"\n{BOLD}{RED}>> Emergency override initiated for {emergency_direction.upper()} direction!{RESET}")
        start_override = time.time()
        try:
            while True:
                elapsed = int(time.time() - start_override)
                if elapsed >= emergency_cross_time:
                    break
                remaining = emergency_cross_time - elapsed
                header_parts = []
                for d in directions:
                    if d.lower() == emergency_direction.lower():
                        header_parts.append(f"{d}: {GREEN}GREEN{RESET} ({remaining}s)")
                    else:
                        header_parts.append(f"{d}: {RED}RED{RESET} (---)")
                header = " | ".join(header_parts)
                print("\n" * 3)
                print(f"{BOLD}{BLUE}--- Emergency Override Signal Status ---{RESET}")
                print(header)
                print("\nEmergency vehicle is crossing... Please clear other lanes.")
                time.sleep(1)
        except KeyboardInterrupt:
            print(f"\n{BOLD}{BLUE}Emergency override interrupted by user.{RESET}")
        print(f"\n{BOLD}{GREEN}>> Emergency override complete. Resuming normal cycle...{RESET}\n")

# SmartTrafficSignal Class
class SmartTrafficSignal(TrafficSignal, EmergencyHandler):
    def __init__(self, config, google_maps, latitude, longitude):
        super().__init__(config)
        self.directions = ["North", "East", "South", "West"]
        self.base_green_duration = config.get("green_light_time", 10)
        self.yellow_duration = config.get("yellow_light_time", 3)
        self.google_maps = google_maps
        self.latitude = latitude
        self.longitude = longitude
        self.traffic_data = self.google_maps.get_traffic_data(self.latitude, self.longitude)
        weather_data = self.google_maps.get_weather_data(self.latitude, self.longitude)
        self.config['weather_condition'] = weather_data['condition']
        self.config['temperature'] = weather_data['temperature']
        self.adjust_signal_timing()
        self.calculate_full_cycle()
        print(f"{BLUE}Smart Traffic Signal installed at coordinates: {latitude}, {longitude}{RESET}")

    def adjust_signal_timing(self):
        self.green_durations = {}
        for direction in self.directions:
            congestion = self.traffic_data.get(direction, "medium")
            if congestion == "high":
                adjustment = 1.5
            elif congestion == "low":
                adjustment = 0.8
            else:
                adjustment = 1.0
            weather = self.config['weather_condition']
            if weather in ["rainy", "snowy", "foggy"]:
                adjustment *= 1.2
            self.green_durations[direction] = max(5, int(self.base_green_duration * adjustment))
        print(f"\n{BOLD}{BLUE}Traffic-optimized signal timings:{RESET}")
        for direction in self.directions:
            congestion = self.traffic_data.get(direction, "medium")
            if congestion == "high":
                congestion_color = RED
            elif congestion == "medium":
                congestion_color = YELLOW
            else:
                congestion_color = GREEN
            print(f" {direction}: {congestion_color}{congestion.upper()}{RESET} â†’ Green duration: {self.green_durations[direction]}s")

    def calculate_full_cycle(self):
        self.full_cycle = sum(self.green_durations.values()) + len(self.directions) * self.yellow_duration

    def update_traffic_data(self):
        self.traffic_data = self.google_maps.get_traffic_data(self.latitude, self.longitude)
        weather_data = self.google_maps.get_weather_data(self.latitude, self.longitude)
        self.config['weather_condition'] = weather_data['condition']
        self.config['temperature'] = weather_data['temperature']
        self.adjust_signal_timing()
        self.calculate_full_cycle()
        print(f"{BLUE}Traffic data updated. New cycle time: {self.full_cycle}s{RESET}")

    def get_direction_state(self, elapsed_time):
        t_cycle = elapsed_time % self.full_cycle
        current_time = 0
        states = {}
        for direction in self.directions:
            green_time = self.green_durations[direction]
            yellow_time = self.yellow_duration
            if current_time <= t_cycle < current_time + green_time:
                states[direction] = {"state": "GREEN", "time_left": current_time + green_time - t_cycle}
            elif current_time + green_time <= t_cycle < current_time + green_time + yellow_time:
                states[direction] = {"state": "YELLOW", "time_left": current_time + green_time + yellow_time - t_cycle}
            else:
                time_until_next_cycle = self.full_cycle - t_cycle if t_cycle > current_time else 0
                time_until_green = (current_time - t_cycle) if current_time > t_cycle else (time_until_next_cycle + current_time)
                states[direction] = {"state": "RED", "time_left": time_until_green}
            current_time += green_time + yellow_time
        return states

    def run_smart_traffic_cycle(self, update_interval=30):
        start_time = time.time()
        last_update = start_time
        simulation_duration = self.config.get("simulation_duration", 60)
        try:
            while True:
                current_time = time.time()
                elapsed = int(current_time - start_time)
                if elapsed > simulation_duration:
                    break
                if int(current_time - last_update) >= update_interval:
                    print(f"\n{BOLD}{BLUE}Updating traffic data...{RESET}")
                    self.update_traffic_data()
                    last_update = current_time
                states = self.get_direction_state(elapsed)
                header_parts = []
                for direction in self.directions:
                    state = states[direction]["state"]
                    time_left = states[direction]["time_left"]
                    congestion = self.traffic_data.get(direction, "medium")
                    col = GREEN if state == "GREEN" else YELLOW if state == "YELLOW" else RED
                    congestion_tag = f"({congestion.upper()})"
                    header_parts.append(f"{direction}: {col}{state}{RESET} ({time_left}s) {congestion_tag}")
                header = " | ".join(header_parts)
                print("\n" * 4)
                print(f"{BOLD}{BLUE}--- Smart Traffic Signal Status at {self.latitude}, {self.longitude} ---{RESET}")
                print(f"{BLUE}Weather: {self.config['weather_condition']}, Temp: {self.config['temperature']}Â°C{RESET}")
                print(header)
                print(f"\nNext traffic data update in {int(update_interval - (current_time - last_update))}s")
                print("\nPress Ctrl+C to exit the cycle.")
                time.sleep(1)
        except KeyboardInterrupt:
            print(f"\n{BOLD}{BLUE}Smart traffic cycle interrupted by user.{RESET}")

    def run_smart_traffic_cycle_with_emergency(self, emergency_arrival_time, emergency_direction, emergency_cross_time, update_interval=30):
        start_time = time.time()
        last_update = start_time
        simulation_duration = self.config.get("simulation_duration", 60)
        emergency_triggered = False
        try:
            while True:
                current_time = time.time()
                elapsed = int(current_time - start_time)
                if elapsed > simulation_duration:
                    break
                if (not emergency_triggered) and (elapsed >= emergency_arrival_time):
                    self.emergency_override(self.directions, emergency_direction, emergency_cross_time)
                    emergency_triggered = True
                    last_update = time.time()
                if int(current_time - last_update) >= update_interval:
                    print(f"\n{BOLD}{BLUE}Updating traffic data...{RESET}")
                    self.update_traffic_data()
                    last_update = current_time
                states = self.get_direction_state(elapsed)
                header_parts = []
                for direction in self.directions:
                    state = states[direction]["state"]
                    time_left = states[direction]["time_left"]
                    congestion = self.traffic_data.get(direction, "medium")
                    col = GREEN if state == "GREEN" else YELLOW if state == "YELLOW" else RED
                    congestion_tag = f"({congestion.upper()})"
                    header_parts.append(f"{direction}: {col}{state}{RESET} ({time_left}s) {congestion_tag}")
                header = " | ".join(header_parts)
                print("\n" * 4)
                print(f"{BOLD}{BLUE}--- Smart Traffic Signal Status at {self.latitude}, {self.longitude} ---{RESET}")
                print(f"{BLUE}Weather: {self.config['weather_condition']}, Temp: {self.config['temperature']}Â°C{RESET}")
                print(header)
                if not emergency_triggered and emergency_arrival_time > elapsed:
                    print(f"\n{YELLOW}Emergency vehicle expected in {emergency_arrival_time - elapsed}s{RESET}")
                print(f"\nNext traffic data update in {int(update_interval - (current_time - last_update))}s")
                print("\nPress Ctrl+C to exit the cycle.")
                time.sleep(1)
        except KeyboardInterrupt:
            print(f"\n{BOLD}{BLUE}Smart traffic cycle interrupted by user.{RESET}")

# Main Function
def main():
    print("\nðŸš¦ Smart Traffic Management System with Google Maps Integration")
    api_key = input("Enter your Google Maps API Key (or press Enter to use simulation mode): ").strip()
    if not api_key:
        print(f"{YELLOW}Using simulation mode without actual Google Maps API calls{RESET}")
    google_maps = GoogleMapsIntegration(api_key)
    while True:
        try:
            latitude = float(input("Enter latitude for the traffic signal: "))
            longitude = float(input("Enter longitude for the traffic signal: "))
            if -90 <= latitude <= 90 and -180 <= longitude <= 180:
                break
            else:
                print(f"{RED}Invalid coordinates! Latitude must be between -90 and 90, longitude between -180 and 180.{RESET}")
        except ValueError:
            print(f"{RED}Invalid input! Please enter numeric values.{RESET}")

    while True:
        try:
            config = {
                'simulation_duration': int(input("Enter simulation duration (sec): ")),
                'num_lanes': int(input("Enter number of lanes on the road: ")),
                'road_condition': "dry",
                'weather_condition': "sunny",
                'temperature': 30,
                'traffic_density': "high",
                'intersection_type': "4-way",
                'yellow_light_time': int(input("Enter base yellow light timer duration (sec): ")),
                'green_light_time': int(input("Enter base green light timer duration (sec): "))
            }
            update_interval = int(input("Enter traffic data update interval (sec, recommended 30-60): "))
            include_emergency = input("Include emergency vehicle in simulation? (y/n): ").lower().strip() == 'y'
            if include_emergency:
                emergency_cross_time = int(input("Enter time needed for emergency vehicle to cross the signal (sec): "))
                emergency_arrival_time = int(input("Enter time at which the emergency vehicle arrives at the signal (sec): "))
                emergency_direction = input("Enter direction of emergency vehicle (North/East/South/West): ").strip()
            else:
                emergency_cross_time = 0
                emergency_arrival_time = 0
                emergency_direction = ""
            break
        except ValueError:
            print(f"{RED}Invalid input! Please enter numeric values where required.{RESET}")

    smart_signal = SmartTrafficSignal(config, google_maps, latitude, longitude)

    while True:
        print("\nðŸš¦ Main Menu:")
        print("1. Run smart traffic signal cycle with live traffic data")
        print("2. Run smart traffic signal cycle with emergency override")
        print("3. View current traffic congestion map")
        print("4. Exit")
        main_choice = input("Enter your choice (1-4): ").strip()
        if main_choice == "1":
            smart_signal.run_smart_traffic_cycle(update_interval)
        elif main_choice == "2":
            if include_emergency:
                smart_signal.run_smart_traffic_cycle_with_emergency(
                    emergency_arrival_time,
                    emergency_direction,
                    emergency_cross_time,
                    update_interval
                )
            else:
                print(f"{YELLOW}Emergency settings not configured. Please run option 1 or reconfigure.{RESET}")
        elif main_choice == "3":
            print(f"\n{BOLD}{BLUE}Current Traffic Conditions at {latitude}, {longitude}:{RESET}")
            for direction, congestion in smart_signal.traffic_data.items():
                color = RED if congestion == "high" else YELLOW if congestion == "medium" else GREEN
                print(f" {direction}: {color}{congestion.upper()}{RESET}")
        elif main_choice == "4":
            print("Exiting the Smart Traffic Management System. Safe travels!")
            break
        else:
            print(f"{RED}Invalid choice! Please enter 1, 2, 3, or 4.{RESET}")

if __name__ == "__main__":
    main()
